# 自动化测试管理平台（ATS）后端需求文档

## 文档信息

| 项目名称 | 自动化测试管理平台（Automated Test System）后端服务 |
|---------|-------------------------------------------|
| 文档版本 | v1.0 |
| 编写日期 | 2025-12-14 |
| 文档状态 | 待评审 |
| 技术栈 | Python (FastAPI) |

---

## 1. 项目概述

### 1.1 项目背景

作为后端开发工程师，需要构建一个企业级自动化测试平台的后端服务。该服务采用RESTful架构，提供完整的测试管理API，支持分布式执行，并与前端和Agent节点进行通信。

### 1.2 核心职责

- 提供RESTful API接口，支持前端应用调用
- 管理测试用例、测试计划、测试执行等核心业务数据
- 支持异步任务处理（用例导入、测试执行等）
- 提供实时通信能力（WebSocket）
- 实现安全认证和权限控制
- 支持文件存储和管理
- 提供数据统计和分析能力

### 1.3 技术选型

- **语言/框架**: Python (FastAPI)
- **数据库**: PostgreSQL + Redis
- **消息队列**: RabbitMQ + Celery
- **文件存储**: MinIO/S3
- **API文档**: OpenAPI 3.0 + Swagger UI
- **认证授权**: JWT + RBAC权限控制

---

## 2. 技术架构

### 2.1 系统架构

```
┌─────────────┐
│  前端应用    │
│  (React)    │
└──────┬──────┘
       │ HTTP/WebSocket
       │
┌──────▼─────────────────────────────────────┐
│         后端服务 (FastAPI)                  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ API路由  │  │ 业务逻辑 │  │ 数据访问 │ │
│  └──────────┘  └──────────┘  └──────────┘ │
└──────┬─────────────────────────────────────┘
       │
       ├──────────┬──────────┬──────────┬──────────┐
       │          │          │          │          │
┌──────▼──┐ ┌─────▼────┐ ┌───▼────┐ ┌───▼────┐ ┌───▼────┐
│PostgreSQL│ │  Redis  │ │RabbitMQ│ │ Celery │ │ MinIO  │
│         │ │         │ │        │ │        │ │        │
└─────────┘ └─────────┘ └────────┘ └────────┘ └────────┘
```

### 2.2 技术栈详情

#### 2.2.1 核心框架

- **FastAPI**: 现代、快速的Web框架，支持异步处理
- **Pydantic**: 数据验证和序列化
- **SQLAlchemy**: ORM框架，支持PostgreSQL
- **Alembic**: 数据库迁移工具

#### 2.2.2 认证与安全

- **python-jose**: JWT令牌生成和验证
- **passlib**: 密码哈希处理
- **bcrypt**: 密码加密算法

#### 2.2.3 异步任务

- **Celery**: 分布式任务队列
- **RabbitMQ**: 消息代理
- **Redis**: Celery结果后端和缓存

#### 2.2.4 文件处理

- **boto3**: S3/MinIO客户端
- **python-multipart**: 文件上传处理

#### 2.2.5 实时通信

- **WebSocket**: FastAPI原生WebSocket支持

#### 2.2.6 其他工具

- **python-dotenv**: 环境变量管理
- **httpx**: HTTP客户端（用于测试）
- **pytest**: 测试框架

---

## 3. 数据库设计

### 3.1 设计原则

- **主键策略**: 核心业务表使用UUID作为主键，关联表使用INTEGER自增ID
- **时间戳**: 所有表包含 `created_at` 和 `updated_at` 字段
- **软删除**: 重要数据支持软删除（通过 `deleted_at` 字段）
- **索引优化**: 为常用查询字段建立索引
- **外键约束**: 使用数据库外键保证数据完整性

### 3.2 核心数据表

#### 3.2.1 用户表（users）

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100),
    phone VARCHAR(20),
    department VARCHAR(100),
    status BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
```

#### 3.2.2 项目表（projects）

```sql
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    owner_id UUID REFERENCES users(id) NOT NULL,
    status VARCHAR(50) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES users(id)
);

CREATE INDEX idx_projects_owner ON projects(owner_id);
CREATE INDEX idx_projects_status ON projects(status);
```

#### 3.2.3 模块表（modules）

```sql
CREATE TABLE modules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE NOT NULL,
    name VARCHAR(100) NOT NULL,
    parent_id UUID REFERENCES modules(id),
    level INTEGER DEFAULT 1,
    sort_order INTEGER DEFAULT 0,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_modules_project ON modules(project_id);
CREATE INDEX idx_modules_parent ON modules(parent_id);
```

#### 3.2.4 测试用例表（test_cases）- 核心表

```sql
CREATE TABLE test_cases (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE NOT NULL,
    module_id UUID REFERENCES modules(id),
    case_code VARCHAR(100) UNIQUE NOT NULL,  -- 用户可读的用例编号，如 TC-PROJECT-001
    name VARCHAR(500) NOT NULL,
    type VARCHAR(50) NOT NULL,  -- functional, interface, ui, performance, security
    priority VARCHAR(20) DEFAULT 'medium',  -- P0, P1, P2, P3 或 high, medium, low
    precondition TEXT,
    steps JSONB NOT NULL,  -- 结构化步骤存储
    expected_result TEXT,
    requirement_ref VARCHAR(255),
    module_path VARCHAR(500),  -- 树形路径: 模块/子模块
    level VARCHAR(20),  -- P0/P1/P2/P3
    executor_id UUID REFERENCES users(id),
    tags JSONB,  -- ["回归", "冒烟"]
    status VARCHAR(50) DEFAULT 'not_executed',  -- not_executed, passed, failed, blocked, skipped
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES users(id) NOT NULL,
    updated_by UUID REFERENCES users(id)
);

CREATE INDEX idx_test_cases_project ON test_cases(project_id);
CREATE INDEX idx_test_cases_module ON test_cases(module_id);
CREATE INDEX idx_test_cases_code ON test_cases(case_code);
CREATE INDEX idx_test_cases_status ON test_cases(status);
CREATE INDEX idx_test_cases_type ON test_cases(type);
CREATE INDEX idx_test_cases_priority ON test_cases(priority);
CREATE INDEX idx_test_cases_tags ON test_cases USING GIN(tags);
```

**测试步骤（steps）JSONB结构示例**:
```json
[
    {
        "step": 1,
        "action": "打开登录页面",
        "expected": "页面正常加载"
    },
    {
        "step": 2,
        "action": "输入用户名和密码",
        "expected": "输入框可正常输入"
    },
    {
        "step": 3,
        "action": "点击登录按钮",
        "expected": "登录成功，跳转到首页"
    }
]
```

#### 3.2.5 用例附件表（case_attachments）

```sql
CREATE TABLE case_attachments (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    case_id UUID REFERENCES test_cases(id) ON DELETE CASCADE NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_size INTEGER,
    file_type VARCHAR(50),
    upload_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    uploaded_by UUID REFERENCES users(id)
);

CREATE INDEX idx_attachments_case ON case_attachments(case_id);
```

#### 3.2.6 测试计划表（test_plans）

```sql
CREATE TABLE test_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE NOT NULL,
    plan_number VARCHAR(50) UNIQUE NOT NULL,  -- 如 TP-20251211-001
    name VARCHAR(255) NOT NULL,
    description TEXT,
    owner_id UUID REFERENCES users(id) NOT NULL,
    plan_type VARCHAR(50) DEFAULT 'functional',  -- functional, regression, special
    start_date DATE,
    end_date DATE,
    cron_expression VARCHAR(100),  -- 定时表达式，如 "0 0 * * *" (每天0点)
    environment_config JSONB,  -- 环境配置信息
    status VARCHAR(50) DEFAULT 'not_started',  -- not_started, running, completed, paused, overdue
    environment_id UUID REFERENCES environments(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_plans_project ON test_plans(project_id);
CREATE INDEX idx_plans_owner ON test_plans(owner_id);
CREATE INDEX idx_plans_status ON test_plans(status);
CREATE INDEX idx_plans_number ON test_plans(plan_number);
```

#### 3.2.7 计划用例关联表（plan_case_relations）

```sql
CREATE TABLE plan_case_relations (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    plan_id UUID REFERENCES test_plans(id) ON DELETE CASCADE NOT NULL,
    case_id UUID REFERENCES test_cases(id) ON DELETE CASCADE NOT NULL,
    assigned_to UUID REFERENCES users(id),
    execution_order INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(plan_id, case_id)
);

CREATE INDEX idx_plan_cases_plan ON plan_case_relations(plan_id);
CREATE INDEX idx_plan_cases_case ON plan_case_relations(case_id);
CREATE INDEX idx_plan_cases_assigned ON plan_case_relations(assigned_to);
```

#### 3.2.8 测试执行表（test_executions）

```sql
CREATE TABLE test_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    plan_id UUID REFERENCES test_plans(id),
    case_id UUID REFERENCES test_cases(id) ON DELETE CASCADE NOT NULL,
    executor_id UUID REFERENCES users(id) NOT NULL,
    environment_id UUID REFERENCES environments(id),
    result VARCHAR(50) NOT NULL,  -- passed, failed, blocked, skipped
    duration FLOAT,  -- 执行耗时（秒）
    notes TEXT,
    error_message TEXT,
    execution_log TEXT,
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_executions_plan ON test_executions(plan_id);
CREATE INDEX idx_executions_case ON test_executions(case_id);
CREATE INDEX idx_executions_executor ON test_executions(executor_id);
CREATE INDEX idx_executions_result ON test_executions(result);
CREATE INDEX idx_executions_executed_at ON test_executions(executed_at);
```

#### 3.2.9 执行附件表（execution_attachments）

```sql
CREATE TABLE execution_attachments (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    execution_id UUID REFERENCES test_executions(id) ON DELETE CASCADE NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_size INTEGER,
    file_type VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_exec_attachments_execution ON execution_attachments(execution_id);
```

#### 3.2.10 测试报告表（test_reports）

```sql
CREATE TABLE test_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id),
    plan_id UUID REFERENCES test_plans(id),
    report_type VARCHAR(50) NOT NULL,  -- execution, plan, project, custom
    report_name VARCHAR(255) NOT NULL,
    start_date DATE,
    end_date DATE,
    report_data JSONB,  -- 报告数据
    summary TEXT,
    created_by UUID REFERENCES users(id) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_reports_project ON test_reports(project_id);
CREATE INDEX idx_reports_plan ON test_reports(plan_id);
CREATE INDEX idx_reports_type ON test_reports(report_type);
```

#### 3.2.11 测试环境表（environments）

```sql
CREATE TABLE environments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    api_url VARCHAR(500),
    web_url VARCHAR(500),
    database_config JSONB,
    env_variables JSONB,
    description TEXT,
    status BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_environments_status ON environments(status);
```

#### 3.2.12 通知表（notifications）

```sql
CREATE TABLE notifications (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    type VARCHAR(50) NOT NULL,  -- plan_reminder, case_assigned, execution_completed, report_generated
    title VARCHAR(255) NOT NULL,
    content TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    related_id UUID,  -- 关联的业务ID（可能是UUID或INTEGER）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_notifications_user ON notifications(user_id);
CREATE INDEX idx_notifications_read ON notifications(is_read);
CREATE INDEX idx_notifications_type ON notifications(type);
CREATE INDEX idx_notifications_created_at ON notifications(created_at);
```

#### 3.2.13 项目成员表（project_members）

```sql
CREATE TABLE project_members (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    role VARCHAR(50) DEFAULT 'member',  -- member, tester, developer, viewer
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(project_id, user_id)
);

CREATE INDEX idx_project_members_project ON project_members(project_id);
CREATE INDEX idx_project_members_user ON project_members(user_id);
```

#### 3.2.14 角色表（roles）

```sql
CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) UNIQUE NOT NULL,  -- admin, project_manager, tester, developer, viewer
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    is_system BOOLEAN DEFAULT FALSE,  -- 系统内置角色不可删除
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_roles_name ON roles(name);
```

#### 3.2.15 权限表（permissions）

```sql
CREATE TABLE permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    code VARCHAR(100) UNIQUE NOT NULL,  -- 权限代码，如 test_case:create, test_plan:execute
    name VARCHAR(100) NOT NULL,
    resource VARCHAR(50) NOT NULL,  -- test_case, test_plan, project, user等
    action VARCHAR(50) NOT NULL,  -- create, read, update, delete, execute等
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_permissions_code ON permissions(code);
CREATE INDEX idx_permissions_resource ON permissions(resource);
```

#### 3.2.16 用户角色关联表（user_roles）

```sql
CREATE TABLE user_roles (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    role_id UUID REFERENCES roles(id) ON DELETE CASCADE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, role_id)
);

CREATE INDEX idx_user_roles_user ON user_roles(user_id);
CREATE INDEX idx_user_roles_role ON user_roles(role_id);
```

#### 3.2.17 角色权限关联表（role_permissions）

```sql
CREATE TABLE role_permissions (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    role_id UUID REFERENCES roles(id) ON DELETE CASCADE NOT NULL,
    permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(role_id, permission_id)
);

CREATE INDEX idx_role_permissions_role ON role_permissions(role_id);
CREATE INDEX idx_role_permissions_permission ON role_permissions(permission_id);
```

#### 3.2.18 项目权限表（project_permissions）

```sql
CREATE TABLE project_permissions (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE NOT NULL,
    granted_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(project_id, user_id, permission_id)
);

CREATE INDEX idx_project_permissions_project ON project_permissions(project_id);
CREATE INDEX idx_project_permissions_user ON project_permissions(user_id);
CREATE INDEX idx_project_permissions_permission ON project_permissions(permission_id);
```

### 3.3 数据关系图

```
用户（User）
  ├── 用户角色（UserRole） → 角色（Role）
  │     └── 角色权限（RolePermission） → 权限（Permission）
  ├── 项目成员（ProjectMember） → 项目（Project）
  └── 项目权限（ProjectPermission） → 权限（Permission）

项目（Project）
  ├── 模块（Module）
  │     └── 测试用例（TestCase）
  │           ├── 用例附件（CaseAttachment）
  │           └── 测试执行（TestExecution）
  │                 └── 执行附件（ExecutionAttachment）
  ├── 测试计划（TestPlan）
  │     ├── 计划用例关联（PlanCaseRelation）
  │     └── 测试报告（TestReport）
  └── 项目成员（ProjectMember）

测试环境（Environment）
  ├── 测试计划（TestPlan）
  └── 测试执行（TestExecution）

通知（Notification） → 用户（User）
```

---

## 4. API接口设计

### 4.1 设计原则

- **RESTful风格**: 遵循REST架构原则，使用HTTP方法表示操作
- **版本控制**: 所有API路径包含版本号 `/api/v1/`
- **统一响应**: 所有接口返回统一的响应格式
- **状态码规范**: 正确使用HTTP状态码
- **错误处理**: 统一的错误处理和错误码
- **分页支持**: 列表接口支持分页、排序、过滤
- **权限控制**: 所有业务接口需要进行权限验证

### 4.2 统一响应格式

```python
from typing import Optional, Any, Dict
from pydantic import BaseModel
from enum import Enum

class ResponseStatus(str, Enum):
    SUCCESS = "success"
    ERROR = "error"
    WARNING = "warning"

class APIResponse(BaseModel):
    status: ResponseStatus
    message: str
    data: Optional[Any] = None
    code: int = 200
    timestamp: str
    request_id: Optional[str] = None

# 成功响应示例
{
    "status": "success",
    "message": "操作成功",
    "data": {
        "id": "123e4567-e89b-12d3-a456-426614174000",
        "name": "登录功能测试"
    },
    "code": 200,
    "timestamp": "2025-12-21T10:30:00Z"
}

# 错误响应示例
{
    "status": "error",
    "message": "权限不足",
    "code": 403,
    "timestamp": "2025-12-21T10:30:00Z"
}
```

### 4.3 分页响应格式

```python
class PaginationResponse(BaseModel):
    items: List[Any]
    total: int
    page: int
    size: int
    pages: int
    has_next: bool
    has_prev: bool

# 示例
{
    "status": "success",
    "message": "获取成功",
    "data": {
        "items": [...],
        "total": 100,
        "page": 1,
        "size": 10,
        "pages": 10,
        "has_next": True,
        "has_prev": False
    },
    "code": 200,
    "timestamp": "2025-12-21T10:30:00Z"
}
```

### 4.4 核心API端点

#### 4.4.1 认证相关接口

**POST /api/v1/auth/login**
- 功能: 用户登录
- 请求体:
```json
{
    "username": "admin",
    "password": "password123"
}
```
- 响应:
```json
{
    "status": "success",
    "message": "登录成功",
    "data": {
        "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
        "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
        "token_type": "bearer",
        "expires_in": 3600,
        "user": {
            "id": "123e4567-e89b-12d3-a456-426614174000",
            "username": "admin",
            "email": "admin@example.com",
            "full_name": "系统管理员"
        }
    }
}
```

**POST /api/v1/auth/refresh**
- 功能: 刷新访问令牌
- 请求体:
```json
{
    "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
}
```

**POST /api/v1/auth/logout**
- 功能: 用户登出

**GET /api/v1/auth/profile**
- 功能: 获取当前用户信息

#### 4.4.2 用户管理接口

**GET /api/v1/users**
- 功能: 获取用户列表（支持分页、搜索）
- 查询参数:
  - `page`: 页码（默认1）
  - `size`: 每页数量（默认20）
  - `search`: 搜索关键词（用户名、邮箱、姓名）
  - `status`: 用户状态（active, inactive）

**POST /api/v1/users**
- 功能: 创建用户
- 请求体:
```json
{
    "username": "testuser",
    "email": "test@example.com",
    "password": "password123",
    "full_name": "测试用户",
    "phone": "13800138000",
    "department": "测试部"
}
```

**GET /api/v1/users/{user_id}**
- 功能: 获取用户详情

**PUT /api/v1/users/{user_id}**
- 功能: 更新用户信息

**DELETE /api/v1/users/{user_id}**
- 功能: 删除用户

#### 4.4.3 项目管理接口

**GET /api/v1/projects**
- 功能: 获取项目列表（支持分页、过滤）

**POST /api/v1/projects**
- 功能: 创建项目
- 请求体:
```json
{
    "name": "自动化测试平台",
    "description": "企业级自动化测试管理系统",
    "owner_id": "123e4567-e89b-12d3-a456-426614174000"
}
```

**GET /api/v1/projects/{project_id}**
- 功能: 获取项目详情

**PUT /api/v1/projects/{project_id}**
- 功能: 更新项目信息

**DELETE /api/v1/projects/{project_id}**
- 功能: 删除项目

**GET /api/v1/projects/{project_id}/members**
- 功能: 获取项目成员列表

**POST /api/v1/projects/{project_id}/members**
- 功能: 添加项目成员

**DELETE /api/v1/projects/{project_id}/members/{user_id}**
- 功能: 移除项目成员

#### 4.4.4 测试用例管理接口（核心功能）

**GET /api/v1/projects/{project_id}/cases**
- 功能: 获取用例列表（支持分页、过滤、排序）
- 查询参数:
  - `page`: 页码
  - `size`: 每页数量
  - `search`: 搜索关键词（用例名称、编号）
  - `module_id`: 模块ID（用于过滤）
  - `type`: 用例类型
  - `priority`: 优先级
  - `status`: 状态
  - `tags`: 标签（JSON数组）
  - `created_by`: 创建人
  - `assignee`: 执行人
  - `sort_by`: 排序字段（name, created_at, updated_at等）
  - `sort_order`: 排序方向（asc, desc）

**GET /api/v1/projects/{project_id}/cases/{case_id}**
- 功能: 获取用例详情

**POST /api/v1/projects/{project_id}/cases**
- 功能: 创建用例
- 请求体:
```json
{
    "case_code": "TC-PROJECT-001",
    "name": "用户登录功能测试",
    "type": "functional",
    "priority": "high",
    "precondition": "用户已注册且账号状态正常",
    "steps": [
        {
            "step": 1,
            "action": "打开登录页面",
            "expected": "页面正常加载"
        },
        {
            "step": 2,
            "action": "输入有效的用户名和密码",
            "expected": "输入框接受输入"
        },
        {
            "step": 3,
            "action": "点击登录按钮",
            "expected": "登录成功，跳转到首页"
        }
    ],
    "expected_result": "用户能够正常登录系统",
    "requirement_ref": "REQ-LOGIN-001",
    "module_path": "用户管理/登录功能",
    "module_id": "module-uuid-here",
    "tags": ["回归", "冒烟"],
    "executor_id": "executor-uuid-here"
}
```

**PUT /api/v1/projects/{project_id}/cases/{case_id}**
- 功能: 更新用例

**DELETE /api/v1/projects/{project_id}/cases/{case_id}**
- 功能: 删除用例

**GET /api/v1/projects/{project_id}/cases/template**
- 功能: 下载用例导入模板（Excel格式）
- 响应: 文件流

**POST /api/v1/projects/{project_id}/cases/import**
- 功能: 导入用例（核心逻辑）
- 请求: multipart/form-data，包含Excel文件
- 异步处理，返回任务ID
- 响应:
```json
{
    "status": "success",
    "message": "导入任务已创建",
    "data": {
        "task_id": "task-uuid-here",
        "status": "pending"
    }
}
```

**GET /api/v1/projects/{project_id}/cases/export**
- 功能: 导出用例
- 查询参数: 支持与获取用例列表相同的过滤条件
- 异步处理，返回任务ID

**GET /api/v1/projects/{project_id}/case-tree**
- 功能: 获取用例树形结构
- 响应:
```json
{
    "status": "success",
    "data": [
        {
            "id": "module-uuid-1",
            "name": "用户管理",
            "type": "module",
            "children": [
                {
                    "id": "module-uuid-1-1",
                    "name": "登录功能",
                    "type": "module",
                    "children": [
                        {
                            "id": "case-uuid-1",
                            "name": "用户登录功能测试",
                            "type": "case",
                            "case_code": "TC-USER-001",
                            "priority": "high"
                        }
                    ]
                }
            ]
        }
    ]
}
```

**POST /api/v1/projects/{project_id}/cases/batch**
- 功能: 批量操作用例
- 请求体:
```json
{
    "action": "delete|update_status|assign|tag",
    "case_ids": ["case-uuid-1", "case-uuid-2"],
    "data": {
        "status": "passed",
        "assignee_id": "user-uuid",
        "tags": ["回归"]
    }
}
```

#### 4.4.5 模块管理接口

**GET /api/v1/projects/{project_id}/modules**
- 功能: 获取项目模块树

**POST /api/v1/projects/{project_id}/modules**
- 功能: 创建模块
- 请求体:
```json
{
    "name": "登录功能",
    "parent_id": "parent-module-uuid",
    "description": "用户登录相关功能"
}
```

**PUT /api/v1/modules/{module_id}**
- 功能: 更新模块信息

**DELETE /api/v1/modules/{module_id}**
- 功能: 删除模块

#### 4.4.6 附件管理接口

**POST /api/v1/cases/{case_id}/attachments**
- 功能: 上传用例附件
- 请求: multipart/form-data

**GET /api/v1/cases/{case_id}/attachments**
- 功能: 获取用例附件列表

**GET /api/v1/attachments/{attachment_id}/download**
- 功能: 下载附件

**DELETE /api/v1/attachments/{attachment_id}**
- 功能: 删除附件

#### 4.4.7 测试计划管理接口

**GET /api/v1/projects/{project_id}/plans**
- 功能: 获取测试计划列表

**POST /api/v1/projects/{project_id}/plans**
- 功能: 创建测试计划
- 请求体:
```json
{
    "plan_number": "TP-20251221-001",
    "name": "12月回归测试计划",
    "description": "12月功能回归测试",
    "plan_type": "regression",
    "start_date": "2025-12-22",
    "end_date": "2025-12-28",
    "environment_id": "env-uuid-here",
    "cron_expression": "0 9 * * 1",  // 每周一上午9点
    "environment_config": {
        "database": "test_db",
        "api_url": "https://api.test.com",
        "browser": "chrome"
    }
}
```

**GET /api/v1/plans/{plan_id}**
- 功能: 获取测试计划详情

**PUT /api/v1/plans/{plan_id}**
- 功能: 更新测试计划

**DELETE /api/v1/plans/{plan_id}**
- 功能: 删除测试计划

**GET /api/v1/plans/{plan_id}/cases**
- 功能: 获取计划包含的用例列表

**POST /api/v1/plans/{plan_id}/cases**
- 功能: 添加用例到计划
- 请求体:
```json
{
    "case_ids": ["case-uuid-1", "case-uuid-2"],
    "execution_order": 1
}
```

**DELETE /api/v1/plans/{plan_id}/cases/{case_id}**
- 功能: 从计划中移除用例

**POST /api/v1/plans/{plan_id}/execute**
- 功能: 触发计划执行
- 异步处理，返回执行任务ID

**POST /api/v1/plans/{plan_id}/stop**
- 功能: 停止执行

**GET /api/v1/plans/{plan_id}/executions**
- 功能: 获取执行历史

#### 4.4.8 测试执行接口

**GET /api/v1/executions/{execution_id}**
- 功能: 获取执行详情

**PUT /api/v1/executions/{execution_id}**
- 功能: 更新执行结果
- 请求体:
```json
{
    "result": "passed",
    "duration": 120.5,
    "notes": "执行正常",
    "error_message": null
}
```

**GET /api/v1/executions/{execution_id}/logs**
- 功能: 获取执行日志

**POST /api/v1/executions/{execution_id}/attachments**
- 功能: 上传执行附件

#### 4.4.9 报告管理接口

**GET /api/v1/projects/{project_id}/reports**
- 功能: 获取项目报告列表

**POST /api/v1/projects/{project_id}/reports**
- 功能: 生成报告
- 请求体:
```json
{
    "report_type": "execution",
    "report_name": "12月测试报告",
    "start_date": "2025-12-01",
    "end_date": "2025-12-31",
    "plan_ids": ["plan-uuid-1", "plan-uuid-2"]
}
```

**GET /api/v1/reports/{report_id}**
- 功能: 获取报告详情

**GET /api/v1/reports/{report_id}/download**
- 功能: 下载报告文件

#### 4.4.10 统计分析接口

**GET /api/v1/projects/{project_id}/statistics**
- 功能: 获取项目统计信息
- 查询参数:
  - `start_date`: 开始日期
  - `end_date`: 结束日期
- 响应:
```json
{
    "status": "success",
    "data": {
        "total_cases": 150,
        "total_executions": 500,
        "pass_rate": 0.85,
        "failure_rate": 0.12,
        "block_rate": 0.03,
        "execution_trend": [
            {
                "date": "2025-12-01",
                "executed": 20,
                "passed": 17,
                "failed": 3
            }
        ],
        "case_distribution": {
            "by_type": {
                "functional": 100,
                "interface": 30,
                "ui": 20
            },
            "by_priority": {
                "P0": 20,
                "P1": 50,
                "P2": 60,
                "P3": 20
            }
        }
    }
}
```

**GET /api/v1/projects/{project_id}/dashboard**
- 功能: 获取项目仪表板数据

#### 4.4.11 通知接口

**GET /api/v1/notifications**
- 功能: 获取用户通知列表

**PUT /api/v1/notifications/{notification_id}/read**
- 功能: 标记通知为已读

**PUT /api/v1/notifications/read-all**
- 功能: 标记所有通知为已读

#### 4.4.12 文件管理接口

**POST /api/v1/files/upload**
- 功能: 通用文件上传
- 支持类型: 图片、文档、Excel等
- 文件大小限制: 10MB

**GET /api/v1/files/{file_id}**
- 功能: 获取文件信息

**DELETE /api/v1/files/{file_id}**
- 功能: 删除文件

### 4.5 WebSocket接口

**WebSocket /api/v1/ws/execution-logs/{execution_id}**
- 功能: 实时推送执行日志
- 连接参数:
  - `token`: JWT令牌
  - `execution_id`: 执行ID
- 消息格式:
```json
{
    "type": "log",
    "timestamp": "2025-12-21T10:30:00Z",
    "data": {
        "level": "info",
        "message": "开始执行用例：用户登录功能测试",
        "step": 1
    }
}
```

**WebSocket /api/v1/ws/notifications**
- 功能: 实时推送通知

---

## 5. 业务逻辑设计

### 5.1 用例管理核心逻辑

#### 5.1.1 用例唯一性保证

```python
def generate_case_code(project_id: UUID, case_name: str) -> str:
    """生成用例编号"""
    # 格式: TC-PROJECT_NAME-001
    project_code = get_project_code(project_id)
    sequence = get_next_sequence(project_id)
    return f"TC-{project_code}-{sequence:03d}"

def validate_case_uniqueness(case_code: str, exclude_id: UUID = None) -> bool:
    """验证用例编号唯一性"""
    query = Case.select().where(Case.case_code == case_code)
    if exclude_id:
        query = query.where(Case.id != exclude_id)
    return not query.exists()
```

#### 5.1.2 树形结构处理

```python
def build_module_tree(project_id: UUID) -> List[Dict]:
    """构建模块树形结构"""
    modules = Module.select().where(
        Module.project_id == project_id
    ).order_by(Module.level, Module.sort_order).all()
    
    def build_tree(parent_id=None):
        tree = []
        for module in modules:
            if module.parent_id == parent_id:
                node = {
                    "id": str(module.id),
                    "name": module.name,
                    "type": "module",
                    "children": build_tree(module.id)
                }
                # 获取该模块下的用例
                cases = TestCase.select().where(
                    TestCase.module_id == module.id
                ).all()
                
                for case in cases:
                    node["children"].append({
                        "id": str(case.id),
                        "name": case.name,
                        "type": "case",
                        "case_code": case.case_code,
                        "priority": case.priority,
                        "status": case.status
                    })
                
                tree.append(node)
        return tree
    
    return build_tree()

def update_module_path(module_id: UUID, new_name: str):
    """更新模块路径"""
    module = Module.get_by_id(module_id)
    old_path = module.module_path
    
    # 更新当前模块
    module.name = new_name
    module.save()
    
    # 递归更新子模块路径
    def update_children(parent_id, parent_path):
        children = Module.select().where(Module.parent_id == parent_id).all()
        for child in children:
            child.module_path = f"{parent_path}/{child.name}"
            child.save()
            update_children(child.id, child.module_path)
    
    update_children(module_id, new_name)
```

#### 5.1.3 导入导出核心逻辑

```python
import pandas as pd
from celery import Celery
from openpyxl import Workbook

@celery_app.task
def import_test_cases_task(project_id: UUID, file_path: str, user_id: UUID) -> Dict:
    """异步导入用例任务"""
    try:
        # 读取Excel文件
        df = pd.read_excel(file_path)
        
        resultstotal": len = {
            "(df),
            "created": 0,
            "updated": 0,
            "failed": 0,
            "errors": []
        }
        
        for index, row in df.iterrows():
            try:
                # 验证必要字段
                if not row.get('name') or not row.get('case_code'):
                    results["failed"] += 1
                    results["errors"].append(f"第{index+2}行: 用例名称和编号不能为空")
                    continue
                
                # 检查用例是否存在
                existing_case = TestCase.select().where(
                    TestCase.case_code == row['case_code']
                ).first()
                
                if existing_case:
                    # 更新用例
                    update_case_from_row(existing_case, row, user_id)
                    results["updated"] += 1
                else:
                    # 创建新用例
                    create_case_from_row(project_id, row, user_id)
                    results["created"] += 1
                    
            except Exception as e:
                results["failed"] += 1
                results["errors"].append(f"第{index+2}行: {str(e)}")
        
        # 清理临时文件
        os.remove(file_path)
        
        return results
        
    except Exception as e:
        return {"error": f"导入失败: {str(e)}"}

def export_test_cases(project_id: UUID, filters: Dict) -> str:
    """导出用例到Excel"""
    # 构建查询
    query = TestCase.select().where(TestCase.project_id == project_id)
    
    # 应用过滤条件
    if filters.get('module_id'):
        query = query.where(TestCase.module_id == filters['module_id'])
    if filters.get('type'):
        query = query.where(TestCase.type == filters['type'])
    if filters.get('priority'):
        query = query.where(TestCase.priority == filters['priority'])
    # ... 其他过滤条件
    
    cases = query.all()
    
    # 创建Excel工作簿
    wb = Workbook()
    ws = wb.active
    ws.title = "测试用例"
    
    # 写入表头
    headers = ['用例编号', '用例名称', '用例类型', '优先级', '前置条件', '测试步骤', '期望结果', '模块路径', '标签', '状态']
    ws.append(headers)
    
    # 写入数据
    for case in cases:
        steps_text = "\n".join([f"{step['step']}. {step['action']}" for step in case.steps])
        tags_text = ",".join(case.tags) if case.tags else ""
        
        ws.append([
            case.case_code,
            case.name,
            case.type,
            case.priority,
            case.precondition or "",
            steps_text,
            case.expected_result or "",
            case.module_path or "",
            tags_text,
            case.status
        ])
    
    # 保存文件
    file_path = f"/tmp/export_{project_id}_{int(time.time())}.xlsx"
    wb.save(file_path)
    
    return file_path
```

### 5.2 测试执行核心逻辑

#### 5.2.1 计划执行流程

```python
@celery_app.task
def execute_test_plan(plan_id: UUID, executor_id: UUID) -> Dict:
    """执行测试计划"""
    try:
        plan = TestPlan.get_by_id(plan_id)
        
        # 更新计划状态
        plan.status = 'running'
        plan.save()
        
        # 获取计划中的用例
        plan_cases = PlanCaseRelation.select().where(
            PlanCaseRelation.plan_id == plan_id
        ).order_by(PlanCaseRelation.execution_order)
        
        results = {
            "plan_id": str(plan_id),
            "total_cases": len(plan_cases),
            "executed": 0,
            "passed": 0,
            "failed": 0,
            "blocked": 0,
            "skipped": 0
        }
        
        for plan_case in plan_cases:
            try:
                # 创建执行记录
                execution = TestExecution.create(
                    plan_id=plan_id,
                    case_id=plan_case.case_id,
                    executor_id=executor_id,
                    environment_id=plan.environment_id,
                    result='not_executed'
                )
                
                # 发送到Agent执行
                task_id = send_to_agent(execution.id, plan_case.case_id)
                
                # 等待执行完成（实际中应该是异步回调）
                execution_result = wait_for_execution(task_id, timeout=3600)
                
                # 更新执行结果
                execution.result = execution_result['result']
                execution.duration = execution_result['duration']
                execution.execution_log = execution_result['log']
                execution.save()
                
                # 统计结果
                results["executed"] += 1
                if execution_result['result'] == 'passed':
                    results["passed"] += 1
                elif execution_result['result'] == 'failed':
                    results["failed"] += 1
                elif execution_result['result'] == 'blocked':
                    results["blocked"] += 1
                else:
                    results["skipped"] += 1
                    
            except Exception as e:
                # 执行失败
                execution.error_message = str(e)
                execution.result = 'failed'
                execution.save()
                results["failed"] += 1
        
        # 更新计划状态
        plan.status = 'completed'
        plan.save()
        
        # 发送通知
        send_execution_notification(plan_id, results)
        
        return results
        
    except Exception as e:
        # 更新计划状态为失败
        plan.status = 'failed'
        plan.save()
        raise e

def send_to_agent(execution_id: UUID, case_id: UUID) -> str:
    """发送执行任务到Agent"""
    case = TestCase.get_by_id(case_id)
    
    task_data = {
        "execution_id": str(execution_id),
        "case": {
            "id": str(case.id),
            "name": case.name,
            "steps": case.steps,
            "expected_result": case.expected_result,
            "environment_config": get_environment_config(case.executor_id)
        }
    }
    
    # 发送到消息队列
    celery_app.send_task('agent.execute_case', args=[task_data])
    
    return f"task_{execution_id}"
```

### 5.3 权限控制逻辑

#### 5.3.1 RBAC权限检查

```python
from functools import wraps
from fastapi import HTTPException, Depends

def check_permission(resource: str, action: str):
    """权限检查装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            user = get_current_user()  # 获取当前用户
            
            # 检查全局权限
            if has_global_permission(user.id, resource, action):
                return await func(*args, **kwargs)
            
            # 检查项目权限
            project_id = kwargs.get('project_id')
            if project_id and has_project_permission(user.id, project_id, resource, action):
                return await func(*args, **kwargs)
            
            raise HTTPException(status_code=403, detail="权限不足")
        
        return wrapper
    return decorator

def has_global_permission(user_id: UUID, resource: str, action: str) -> bool:
    """检查全局权限"""
    query = """
    SELECT COUNT(*) > 0
    FROM user_roles ur
    JOIN role_permissions rp ON ur.role_id = rp.role_id
    JOIN permissions p ON rp.permission_id = p.id
    WHERE ur.user_id = ? AND p.resource = ? AND p.action = ?
    """
    return execute_scalar(query, user_id, resource, action)

def has_project_permission(user_id: UUID, project_id: UUID, resource: str, action: str) -> bool:
    """检查项目权限"""
    query = """
    SELECT COUNT(*) > 0
    FROM project_permissions pp
    JOIN permissions p ON pp.permission_id = p.id
    WHERE pp.user_id = ? AND pp.project_id = ? 
    AND p.resource = ? AND p.action = ?
    """
    return execute_scalar(query, user_id, project_id, resource, action)

# 使用示例
@check_permission('test_case', 'create')
async def create_case(project_id: UUID, case_data: CaseCreate):
    # 创建用例逻辑
    pass
```

---

## 6. 安全设计

### 6.1 认证机制

#### 6.1.1 JWT令牌设计

```python
from jose import JWTError, jwt
from datetime import datetime, timedelta
from passlib.context import CryptContext

# JWT配置
SECRET_KEY = os.getenv("JWT_SECRET_KEY")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60
REFRESH_TOKEN_EXPIRE_DAYS = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def create_access_token(data: dict, expires_delta: timedelta = None):
    """创建访问令牌"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire, "type": "access"})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: dict):
    """创建刷新令牌"""
    expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(token: str, token_type: str = "access"):
    """验证令牌"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        token_type_from_token: str = payload.get("type")
        
        if token_type_from_token != token_type:
            raise HTTPException(status_code=401, detail="令牌类型无效")
        
        if user_id is None:
            raise HTTPException(status_code=401, detail="令牌无效")
        
        return user_id
        
    except JWTError:
        raise HTTPException(status_code=401, detail="令牌验证失败")
```

#### 6.1.2 用户认证流程

```python
async def authenticate_user(username: str, password: str) -> User:
    """用户认证"""
    user = User.select().where(User.username == username).first()
    
    if not user or not verify_password(password, user.password_hash):
        raise HTTPException(status_code=401, detail="用户名或密码错误")
    
    if not user.status:
        raise HTTPException(status_code=401, detail="用户账号已被禁用")
    
    return user

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """验证密码"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """生成密码哈希"""
    return pwd_context.hash(password)
```

### 6.2 授权机制

#### 6.2.1 权限定义

```python
# 系统权限定义
SYSTEM_PERMISSIONS = {
    # 用户管理
    "user:create": "创建用户",
    "user:read": "查看用户",
    "user:update": "更新用户",
    "user:delete": "删除用户",
    
    # 项目管理
    "project:create": "创建项目",
    "project:read": "查看项目",
    "project:update": "更新项目",
    "project:delete": "删除项目",
    "project:manage_members": "管理项目成员",
    
    # 用例管理
    "test_case:create": "创建用例",
    "test_case:read": "查看用例",
    "test_case:update": "更新用例",
    "test_case:delete": "删除用例",
    "test_case:import": "导入用例",
    "test_case:export": "导出用例",
    
    # 计划管理
    "test_plan:create": "创建计划",
    "test_plan:read": "查看计划",
    "test_plan:update": "更新计划",
    "test_plan:delete": "删除计划",
    "test_plan:execute": "执行计划",
    
    # 执行管理
    "test_execution:read": "查看执行记录",
    "test_execution:update": "更新执行结果",
    
    # 报告管理
    "report:create": "生成报告",
    "report:read": "查看报告",
    "report:delete": "删除报告",
    
    # 系统管理
    "system:manage": "系统管理"
}

# 系统角色定义
SYSTEM_ROLES = {
    "admin": {
        "name": "系统管理员",
        "permissions": list(SYSTEM_PERMISSIONS.keys())
    },
    "project_manager": {
        "name": "项目经理",
        "permissions": [
            "project:create", "project:read", "project:update", "project:delete",
            "project:manage_members", "test_case:create", "test_case:read", 
            "test_case:update", "test_case:delete", "test_case:import", 
            "test_case:export", "test_plan:create", "test_plan:read", 
            "test_plan:update", "test_plan:delete", "test_plan:execute",
            "test_execution:read", "test_execution:update", "report:create",
            "report:read"
        ]
    },
    "tester": {
        "name": "测试工程师",
        "permissions": [
            "test_case:create", "test_case:read", "test_case:update",
            "test_plan:read", "test_plan:execute", "test_execution:read",
            "test_execution:update", "report:read"
        ]
    },
    "developer": {
        "name": "开发工程师",
        "permissions": [
            "test_case:read", "test_execution:read", "report:read"
        ]
    },
    "viewer": {
        "name": "观察者",
        "permissions": [
            "test_case:read", "test_plan:read", "test_execution:read", "report:read"
        ]
    }
}
```

### 6.3 数据安全

#### 6.3.1 SQL注入防护

```python
from sqlalchemy import text

# 使用参数化查询
def get_cases_by_project(project_id: UUID, filters: dict):
    query = """
    SELECT * FROM test_cases 
    WHERE project_id = :project_id
    """
    params = {"project_id": project_id}
    
    # 动态添加过滤条件
    if filters.get('status'):
        query += " AND status = :status"
        params['status'] = filters['status']
    
    if filters.get('search'):
        query += " AND (name ILIKE :search OR case_code ILIKE :search)"
        params['search'] = f"%{filters['search']}%"
    
    # 使用text()确保参数化
    return execute(text(query), **params)
```

#### 6.3.2 文件上传安全

```python
import mimetypes
from pathlib import Path

# 允许的文件类型
ALLOWED_EXTENSIONS = {'.pdf', '.doc', '.docx', '.xls', '.xlsx', '.png', '.jpg', '.jpeg', '.gif'}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

def validate_file_upload(file: UploadFile):
    """验证上传文件"""
    # 检查文件扩展名
    file_extension = Path(file.filename).suffix.lower()
    if file_extension not in ALLOWED_EXTENSIONS:
        raise HTTPException(status_code=400, detail="不支持的文件类型")
    
    # 检查文件大小
    file.file.seek(0, 2)  # 移动到文件末尾
    file_size = file.file.tell()
    file.file.seek(0)  # 重置到文件开头
    
    if file_size > MAX_FILE_SIZE:
        raise HTTPException(status_code=400, detail="文件大小超过限制")
    
    # 检查MIME类型
    mime_type, _ = mimetypes.guess_type(file.filename)
    allowed_mime_types = {
        'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'image/png', 'image/jpeg', 'image/gif'
    }
    
    if mime_type not in allowed_mime_types:
        raise HTTPException(status_code=400, detail="文件类型不匹配")
    
    return True

def secure_filename(filename: str) -> str:
    """安全的文件名处理"""
    # 移除危险字符
    filename = re.sub(r'[<>:"/\\|?*]', '', filename)
    
    # 限制文件名长度
    if len(filename) > 255:
        name, ext = os.path.splitext(filename)
        filename = name[:250] + ext
    
    return filename
```

### 6.4 API安全

#### 6.4.1 请求限流

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)

@app.post("/api/v1/auth/login")
@limiter.limit("5/minute")
async def login(request: Request, user_data: UserLogin):
    # 登录逻辑
    pass

@app.post("/api/v1/files/upload")
@limiter.limit("10/minute")
async def upload_file(request: Request, file: UploadFile = File(...)):
    # 文件上传逻辑
    pass
```

#### 6.4.2 CORS配置

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://your-frontend-domain.com"],  # 生产环境指定具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

#### 6.4.3 请求日志和监控

```python
import logging
from fastapi import Request
import time

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """记录请求日志"""
    start_time = time.time()
    
    # 记录请求信息
    logging.info(f"请求开始: {request.method} {request.url.path}")
    
    response = await call_next(request)
    
    # 记录响应信息
    process_time = time.time() - start_time
    logging.info(f"请求完成: {request.method} {request.url.path} - {response.status_code} - {process_time:.4f}s")
    
    # 添加响应头
    response.headers["X-Process-Time"] = str(process_time)
    
    return response
```

---

## 7. 部署和运维

### 7.1 部署架构

#### 7.1.1 容器化部署

**Dockerfile**

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY .. .

# 创建非root用户
RUN useradd --create-home --shell /bin/bash app \
    && chown -R app:app /app
USER app

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**docker-compose.yml**
```yaml
version: '3.8'

services:
  # FastAPI应用
  ats-backend:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://ats_user:ats_password@postgres:5432/ats_db
      - REDIS_URL=redis://redis:6379/0
      - RABBITMQ_URL=amqp://rabbitmq:5672
      - JWT_SECRET_KEY=${JWT_SECRET_KEY}
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
      - MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
    depends_on:
      - postgres
      - redis
      - rabbitmq
      - minio
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  # PostgreSQL数据库
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=ats_db
      - POSTGRES_USER=ats_user
      - POSTGRES_PASSWORD=ats_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    restart: unless-stopped

  # Redis缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  # RabbitMQ消息队列
  rabbitmq:
    image: rabbitmq:3-management
    environment:
      - RABBITMQ_DEFAULT_USER=ats_user
      - RABBITMQ_DEFAULT_PASS=ats_password
    ports:
      - "5672:5672"
      - "15672:15672"  # 管理界面
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    restart: unless-stopped

  # MinIO文件存储
  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      - MINIO_ROOT_USER=${MINIO_ACCESS_KEY}
      - MINIO_ROOT_PASSWORD=${MINIO_SECRET_KEY}
    volumes:
      - minio_data:/data
    restart: unless-stopped

  # Celery Worker
  celery-worker:
    build: .
    command: celery -A main.celery worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql://ats_user:ats_password@postgres:5432/ats_db
      - REDIS_URL=redis://redis:6379/0
      - RABBITMQ_URL=amqp://rabbitmq:5672
    depends_on:
      - postgres
      - redis
      - rabbitmq
    restart: unless-stopped

  # Celery Flower (监控)
  celery-flower:
    build: .
    command: celery -A main.celery flower
    ports:
      - "5555:5555"
    environment:
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - redis
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
  minio_data:
```

### 7.2 环境配置

#### 7.2.1 环境变量配置

**.env文件**
```bash
# 数据库配置
DATABASE_URL=postgresql://ats_user:ats_password@localhost:5432/ats_db
REDIS_URL=redis://localhost:6379/0

# 消息队列配置
RABBITMQ_URL=amqp://ats_user:ats_password@localhost:5672

# JWT配置
JWT_SECRET_KEY=your-super-secret-jwt-key-change-in-production
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=60
REFRESH_TOKEN_EXPIRE_DAYS=30

# 文件存储配置
MINIO_ENDPOINT=localhost:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_SECURE=false
MINIO_BUCKET_NAME=ats-files

# API配置
API_V1_STR=/api/v1
PROJECT_NAME=ATS-Backend
PROJECT_VERSION=1.0.0

# CORS配置
BACKEND_CORS_ORIGINS=["http://localhost:3000", "http://localhost:8080"]

# 日志配置
LOG_LEVEL=INFO
LOG_FILE=/app/logs/ats.log

# 邮件配置
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=noreply@example.com
SMTP_PASSWORD=your-email-password
SMTP_TLS=true

# 监控配置
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
```

### 7.3 监控和日志

#### 7.3.1 应用监控

```python
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
from sentry_sdk.integrations.celery import CeleryIntegration

# Sentry配置
sentry_sdk.init(
    dsn=os.getenv("SENTRY_DSN"),
    integrations=[
        FastApiIntegration(auto_enabling=True),
        SqlalchemyIntegration(),
        CeleryIntegration(monitor_beat_tasks=True),
    ],
    traces_sample_rate=1.0,
    environment=os.getenv("ENVIRONMENT", "development")
)

# 健康检查
@app.get("/health")
async def health_check():
    """健康检查接口"""
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {}
    }
    
    # 检查数据库连接
    try:
        db.execute(text("SELECT 1"))
        health_status["services"]["database"] = "healthy"
    except Exception as e:
        health_status["services"]["database"] = f"unhealthy: {str(e)}"
        health_status["status"] = "unhealthy"
    
    # 检查Redis连接
    try:
        redis_client.ping()
        health_status["services"]["redis"] = "healthy"
    except Exception as e:
        health_status["services"]["redis"] = f"unhealthy: {str(e)}"
        health_status["status"] = "unhealthy"
    
    # 检查RabbitMQ连接
    try:
        channel.queue_declare(queue='health_check', passive=True)
        health_status["services"]["rabbitmq"] = "healthy"
    except Exception as e:
        health_status["services"]["rabbitmq"] = f"unhealthy: {str(e)}"
        health_status["status"] = "unhealthy"
    
    status_code = 200 if health_status["status"] == "healthy" else 503
    return JSONResponse(content=health_status, status_code=status_code)
```

#### 7.3.2 日志配置

```python
import logging
from logging.handlers import RotatingFileHandler
import structlog

# 配置结构化日志
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

# 配置日志
def setup_logging():
    """设置日志配置"""
    log_level = os.getenv("LOG_LEVEL", "INFO")
    
    # 创建日志目录
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    
    # 配置根日志器
    logging.basicConfig(
        level=getattr(logging, log_level),
        format="%(message)s",
        stream=sys.stdout,
    )
    
    # 文件处理器
    file_handler = RotatingFileHandler(
        "logs/ats.log",
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setLevel(log_level)
    
    # 错误日志处理器
    error_handler = RotatingFileHandler(
        "logs/error.log",
        maxBytes=10*1024*1024,
        backupCount=5
    )
    error_handler.setLevel(logging.ERROR)
    
    # 获取特定日志器
    logger = logging.getLogger("ats")
    logger.addHandler(file_handler)
    logger.addHandler(error_handler)
    
    return logger

# 使用示例
logger = structlog.get_logger()

@app.post("/api/v1/cases")
async def create_case(case_data: CaseCreate, current_user: User = Depends(get_current_user)):
    logger.info(
        "创建测试用例",
        user_id=str(current_user.id),
        case_name=case_data.name,
        project_id=str(case_data.project_id)
    )
    
    try:
        # 创建用例逻辑
        case = await case_service.create_case(case_data, current_user.id)
        
        logger.info(
            "用例创建成功",
            case_id=str(case.id),
            case_code=case.case_code
        )
        
        return case
    except Exception as e:
        logger.error(
            "用例创建失败",
            error=str(e),
            case_name=case_data.name,
            exc_info=True
        )
        raise
```

---

## 8. 交付物清单

### 8.1 源代码交付

```
backend/
├── main.py                 # FastAPI应用入口
├── config.py              # 配置文件
├── database.py            # 数据库连接
├── models/                # 数据模型
│   ├── __init__.py
│   ├── user.py
│   ├── project.py
│   ├── test_case.py
│   ├── test_plan.py
│   ├── test_execution.py
│   └── base.py
├── schemas/               # Pydantic模式
│   ├── __init__.py
│   ├── user.py
│   ├── project.py
│   ├── test_case.py
│   ├── test_plan.py
│   ├── test_execution.py
│   └── auth.py
├── api/                   # API路由
│   ├── __init__.py
│   ├── v1/
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── users.py
│   │   ├── projects.py
│   │   ├── test_cases.py
│   │   ├── test_plans.py
│   │   ├── test_executions.py
│   │   ├── reports.py
│   │   ├── files.py
│   │   └── websocket.py
│   └── deps.py            # 依赖注入
├── services/              # 业务逻辑
│   ├── __init__.py
│   ├── auth_service.py
│   ├── user_service.py
│   ├── project_service.py
│   ├── test_case_service.py
│   ├── test_plan_service.py
│   ├── test_execution_service.py
│   ├── file_service.py
│   └── notification_service.py
├── core/                  # 核心功能
│   ├── __init__.py
│   ├── security.py        # 安全相关
│   ├── permissions.py     # 权限控制
│   ├── celery_app.py      # Celery配置
│   └── validators.py      # 验证器
├── utils/                 # 工具函数
│   ├── __init__.py
│   ├── excel_handler.py   # Excel处理
│   ├── file_handler.py    # 文件处理
│   ├── date_utils.py      # 日期工具
│   └── encryption.py      # 加密工具
├── tests/                 # 测试文件
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_auth.py
│   ├── test_users.py
│   ├── test_projects.py
│   ├── test_test_cases.py
│   ├── test_test_plans.py
│   └── test_test_executions.py
├── alembic/               # 数据库迁移
│   ├── versions/
│   └── env.py
├── requirements.txt       # Python依赖
├── Dockerfile            # Docker配置
├── docker-compose.yml    # Docker Compose配置
├── .env.example          # 环境变量示例
├── .gitignore           # Git忽略文件
└── README.md            # 项目说明
```

### 8.2 文档交付

#### 8.2.1 API文档

- **OpenAPI 3.0规范**: `/api/docs` 路径可访问Swagger UI
- **API接口文档**: 完整的API接口说明文档
- **Postman集合**: API测试用例集合文件

#### 8.2.2 部署文档

- **部署指南**: 详细的部署步骤说明
- **环境配置**: 环境变量配置说明
- **Docker部署**: 容器化部署指南
- **数据库迁移**: 数据库初始化和迁移说明

#### 8.2.3 开发文档

- **代码规范**: 开发规范和代码风格指南
- **数据库设计**: 完整的数据库设计文档
- **业务逻辑**: 核心业务逻辑说明
- **安全设计**: 安全机制和权限控制说明

### 8.3 数据库交付

#### 8.3.1 初始化脚本

```sql
-- 创建数据库
CREATE DATABASE ats_db;

-- 创建用户
CREATE USER ats_user WITH PASSWORD 'ats_password';

-- 授权
GRANT ALL PRIVILEGES ON DATABASE ats_db TO ats_user;

-- 初始化数据
\i init_data.sql
```

#### 8.3.2 迁移脚本

```bash
# 生成迁移文件
alembic revision --autogenerate -m "Initial migration"

# 执行迁移
alembic upgrade head

# 回滚迁移
alembic downgrade -1
```

### 8.4 测试交付

#### 8.4.1 单元测试

- **测试覆盖率**: 目标覆盖率 ≥ 80%
- **关键功能测试**: 核心业务逻辑的完整测试
- **边界条件测试**: 异常情况和边界条件测试

#### 8.4.2 集成测试

- **API测试**: 所有API接口的功能测试
- **数据库测试**: 数据库操作测试
- **文件上传测试**: 文件处理功能测试

#### 8.4.3 性能测试

- **负载测试**: API接口的负载能力测试
- **并发测试**: 并发访问处理能力
- **数据库性能**: 查询和事务性能测试

### 8.5 运维交付

#### 8.5.1 监控配置

- **应用监控**: 性能指标监控
- **日志监控**: 错误日志和异常监控
- **业务监控**: 核心业务指标监控

#### 8.5.2 备份策略

- **数据库备份**: 定期数据备份策略
- **文件备份**: 上传文件的备份策略
- **配置备份**: 重要配置文件的备份

#### 8.5.3 应急处理

- **故障处理**: 常见故障的处理流程
- **数据恢复**: 数据丢失的恢复方案
- **性能优化**: 性能问题的排查和优化方案

---

## 9. 质量保证

### 9.1 代码质量

#### 9.1.1 代码规范

- **PEP 8**: 遵循Python代码规范
- **类型注解**: 完整的类型提示
- **文档字符串**: 完整的函数和类文档
- **代码注释**: 关键逻辑的注释说明

#### 9.1.2 代码审查

- **提交前检查**: 本地代码质量检查
- **Pull Request审查**: 团队代码审查流程
- **自动化检查**: CI/CD中的自动化代码质量检查

```python
# pre-commit配置
repos:
  - repo: https://github.com/psf/black
    rev: 22.3.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.10.1
    hooks:
      - id: isort
  - repo: https://github.com/pycqa/flake8
    rev: 4.0.1
    hooks:
      - id: flake8
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v0.950
    hooks:
      - id: mypy
```

### 9.2 测试质量

#### 9.2.1 测试策略

- **测试金字塔**: 单元测试、集成测试、端到端测试
- **测试优先级**: 核心功能优先测试
- **回归测试**: 重要功能的回归测试套件

#### 9.2.2 测试工具

```python
# pytest配置
[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "--cov=.",
    "--cov-report=html",
    "--cov-report=term-missing",
    "--cov-fail-under=80",
    "-v"
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: marks tests as integration tests",
    "unit: marks tests as unit tests"
]
```

### 9.3 性能质量

#### 9.3.1 性能基准

- **API响应时间**: P95 < 500ms
- **数据库查询**: 复杂查询 < 2s
- **文件上传**: 10MB文件 < 30s
- **并发处理**: 支持100+并发用户

#### 9.3.2 性能优化

```python
# 数据库查询优化
from sqlalchemy.orm import selectinload

# 预加载关联数据
query = select(TestCase).options(
    selectinload(TestCase.project),
    selectinload(TestCase.module)
).where(TestCase.project_id == project_id)

# 分页查询优化
def get_cases_paginated(page: int, size: int):
    offset = (page - 1) * size
    query = TestCase.select().limit(size).offset(offset)
    return query.all()
```

---

## 10. 总结

本后端需求文档详细描述了企业级自动化测试平台后端服务的完整技术方案，包括：

### 10.1 核心特性

1. **完整的API体系**: 提供RESTful API，支持测试用例、测试计划、测试执行等核心功能
2. **强大的权限控制**: 基于RBAC的细粒度权限管理
3. **异步任务处理**: 使用Celery处理耗时任务，提升系统响应性能
4. **实时通信**: WebSocket支持实时日志推送和通知
5. **文件管理**: 完整的文件上传、存储、管理功能
6. **数据导入导出**: 支持Excel格式的用例导入导出
7. **统计分析**: 提供丰富的测试数据统计和分析功能

### 10.2 技术亮点

1. **现代技术栈**: FastAPI + PostgreSQL + Redis + RabbitMQ + MinIO
2. **容器化部署**: 完整的Docker容器化方案
3. **微服务架构**: 模块化设计，易于扩展和维护
4. **安全性**: JWT认证、权限控制、数据加密、SQL注入防护
5. **可观测性**: 完整的日志、监控、告警体系
6. **高可用性**: 支持水平扩展和负载均衡

### 10.3 交付标准

1. **代码质量**: 80%+测试覆盖率，完整的代码文档
2. **性能标准**: 满足企业级应用的性能要求
3. **安全标准**: 符合企业安全规范
4. **运维标准**: 完整的部署、监控、备份方案

通过本方案的实施，可以构建一个功能完整、性能优异、安全可靠的企业级自动化测试管理平台，为企业的测试工作提供强有力的技术支撑。

---

*文档版本: v1.0*  
*最后更新: 2025-12-21*  
*作者: 后端开发团队*

---